<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Animated Shapes Gallery</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap');

    body {
      margin: 0;
      padding: 30px;
      background: #0b0c10;
      font-family: 'Orbitron', sans-serif;
      color: #00ffff;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 30px;
    }

    .shape-box {
      width: 30%;
      min-width: 250px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    canvas {
      width: 100%;
      aspect-ratio: 1 / 1;
      background: #000;
      border-radius: 12px;
      border: 2px solid #00ffff44;
    }

    h2 {
      margin: 10px 0 15px;
      text-align: center;
      color: #00ffff;
    }
  </style>
</head>
<body>

  <div class="shape-box"><h2>Cube 3D</h2><canvas id="cube3d"></canvas></div>
  <div class="shape-box"><h2>Cube 4D</h2><canvas id="cube4d"></canvas></div>
  <div class="shape-box"><h2>Ball 3D</h2><canvas id="ball3d"></canvas></div>
  <div class="shape-box"><h2>Pyramid</h2><canvas id="pyramid"></canvas></div>
  <div class="shape-box"><h2>Torus</h2><canvas id="torus"></canvas></div>
  <div class="shape-box"><h2>Cylinder</h2><canvas id="cylinder"></canvas></div>
  <div class="shape-box"><h2>Octahedron</h2><canvas id="octahedron"></canvas></div>
  <div class="shape-box"><h2>Icosahedron</h2><canvas id="icosahedron"></canvas></div>

  <!-- Load Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    function setupScene(canvas) {
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      camera.position.z = 3;
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(2, 2, 5).normalize();
      scene.add(light);
      return { renderer, scene, camera };
    }

    function renderShape(canvasId, geometry) {
      const canvas = document.getElementById(canvasId);
      const { renderer, scene, camera } = setupScene(canvas);
      const mesh = new THREE.Mesh(geometry, new THREE.MeshNormalMaterial());
      scene.add(mesh);
      function animate() {
        requestAnimationFrame(animate);
        mesh.rotation.x += 0.01;
        mesh.rotation.y += 0.01;
        renderer.render(scene, camera);
      }
      animate();
    }

    // Render 3D shapes
    renderShape('cube3d', new THREE.BoxGeometry());
    renderShape('ball3d', new THREE.SphereGeometry(0.8, 32, 32));
    renderShape('pyramid', new THREE.ConeGeometry(1, 1.5, 4));
    renderShape('torus', new THREE.TorusGeometry(0.7, 0.25, 16, 100));
    renderShape('cylinder', new THREE.CylinderGeometry(0.7, 0.7, 1.5, 32));
    renderShape('octahedron', new THREE.OctahedronGeometry(1));
    renderShape('icosahedron', new THREE.IcosahedronGeometry(1));

    // Cube 4D (Tesseract) with animated rotation & neon glow
    {
      const canvas = document.getElementById('cube4d');
      const ctx = canvas.getContext('2d');

      function resizeCanvas() {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      const size = 100;
      let angle = 0;
      const vertices = [];
      for (let i = 0; i < 16; i++) {
        vertices.push([
          (i & 1) ? 1 : -1,
          (i & 2) ? 1 : -1,
          (i & 4) ? 1 : -1,
          (i & 8) ? 1 : -1
        ]);
      }

      function project([x, y, z, w]) {
        const perspective = 4;
        const scale = 1 / (perspective - w);
        return [x * scale, y * scale];
      }

      function rotate4D(p, angle) {
        let [x, y, z, w] = p;

        // Multi-plane 4D rotation
        let xw = Math.cos(angle * 0.8) * x - Math.sin(angle * 0.8) * w;
        let ww1 = Math.sin(angle * 0.8) * x + Math.cos(angle * 0.8) * w;

        let yy = Math.cos(angle * 0.6) * y - Math.sin(angle * 0.6) * z;
        let zz = Math.sin(angle * 0.6) * y + Math.cos(angle * 0.6) * z;

        let zw = Math.cos(angle) * zz - Math.sin(angle) * ww1;
        let ww2 = Math.sin(angle) * zz + Math.cos(angle) * ww1;

        return [xw, yy, zw, ww2];
      }

      function draw() {
        ctx.fillStyle = "#000"; // Black background
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const points = vertices.map(v => rotate4D(v, angle)).map(project);

        const hue = (Date.now() / 30) % 360;
        ctx.strokeStyle = `hsl(${hue}, 100%, 70%)`;
        ctx.shadowColor = `hsl(${hue}, 100%, 70%)`;
        ctx.lineWidth = 1.5;
        ctx.shadowBlur = 8;

        ctx.beginPath();
        for (let i = 0; i < 16; i++) {
          for (let j = 0; j < 4; j++) {
            let neighbor = i ^ (1 << j);
            if (i < neighbor) {
              let [x1, y1] = points[i];
              let [x2, y2] = points[neighbor];
              ctx.moveTo(x1 * size + canvas.width / 2, y1 * size + canvas.height / 2);
              ctx.lineTo(x2 * size + canvas.width / 2, y2 * size + canvas.height / 2);
            }
          }
        }
        ctx.stroke();

        angle += 0.01;
        requestAnimationFrame(draw);
      }

      draw();
    }
  </script>
</body>
</html>
